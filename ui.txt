for i, v in getgc() do

	if typeof(v) == "function" and string.find(debug.info(v, "s"), "AnalyticsPipelineController") then

		hookfunction(v, function()

			return task.wait(9e9)

		end)

	end

end

local a = loadstring(game:HttpGet("https://github.com/PhantomHookWebsiteManager/23984_dontlookinhereok/raw/refs/heads/main/ui.txt"))()


-- =======================================

a:Notify("Disabled rivals anti cheat", 3)
local b = game:GetService("Players")
local c = game:GetService("RunService")
local d = game:GetService("UserInputService")
local e = b.LocalPlayer
local f = e.Character or e.CharacterAdded:Wait()
local g = f:WaitForChild("HumanoidRootPart")
local h = f:WaitForChild("Humanoid")
local i = g.CFrame
local j = 0
local k = 0
local l = false
local m = 0
local n = 0.5
local orbitTarget = nil
local lastOrbitUpdate = 0
local orbitAngle = 0

local HttpService = game:GetService("HttpService")
local configFolder = "VoidHideConfigs"
local defaultConfig = "default.json"


local o = {
	Enabled = false,
	VoidDistance = 1000000,
	VoidDistancePercent = 5,
	HeightOffset = 0,
	Mode = "None",
	SpinSpeed = 10,
	OrbitSpeed = 1.5,
	OrbitRadius = 25,
	FloatSpeed = 2,
	FloatIntensity = 5,
	JitterIntensity = 5,
	DesyncSpeed = 50,
	NoCollide = false,
	Anchor = false,
	AAEnabled = false,
	AAMode = "None",
	AAPitch = "None",
	AASpeed = 15,
	JitterRange = 45,
	SoundId = "rbxassetid://719384308",
	HitsoundId = 719384308,
	OrbitEnabled = false,
	OrbitDistance = 10,
	OrbitHeightOffset = 0,
	OrbitUpdateRate = 0.5,
	OrbitAroundEnemy = false,
	OrbitAroundRadius = 10,
	OrbitAroundSpeed = 2,
	AlwaysHit = false,
	RapidFire = false,
	AutoLoadConfig = true,
	LastLoadedConfig = "default",
	HitEffectType = "Neon",
	HitEffectEnabled = true,
	HitEffectFadeInTime = 0.1,
	HitEffectFadeOutTime = 0.3,
	HitEffectColor = Color3.fromRGB(85, 255, 255),
	-- Lighting Settings
	LightingEnabled = false,
	Brightness = 2,
	AmbientColor = Color3.fromRGB(128, 128, 128),
	OutdoorAmbient = Color3.fromRGB(128, 128, 128),
	ClockTime = 14,
	FogEnd = 1000,
	FogColor = Color3.fromRGB(192, 192, 192),
	-- Chams Settings
	ChamsEnabled = false,
	ChamsFillColor = Color3.fromRGB(255, 0, 255),
	ChamsFillTransparency = 0.5,
	ChamsOutlineColor = Color3.fromRGB(255, 255, 255),
	ChamsOutlineTransparency = 0,
	-- ESP Settings
	ESPEnabled = false,
	ESPIgnoreTeammates = true,
	ESPShowBox = true,
	ESPShowName = true,
	ESPShowDistance = true,
	ESPShowHealthBar = true,
	ESPShowSkeleton = false,
	ESPShowTracers = false,
	ESPMaxDistance = 1000,
	-- ESP Box
	ESPColor = Color3.fromRGB(255, 0, 0),
	ESPTeamColor = Color3.fromRGB(0, 255, 0),
	ESPBoxThickness = 1.5,
	ESPBoxFilled = false,
	ESPBoxFillTransparency = 0.85,
	-- ESP Text
	ESPNameColor = Color3.fromRGB(255, 255, 255),
	ESPNameSize = 14,
	ESPNameOutline = true,
	ESPDistColor = Color3.fromRGB(255, 255, 255),
	ESPDistSize = 12,
	ESPDistOutline = true,
	-- ESP Tracer
	ESPTracerThickness = 1,
	ESPTracerOrigin = "Bottom",
	-- ESP Skeleton
	ESPSkeletonThickness = 1,
	-- ESP Health Bar
	ESPHealthBarWidth = 4,
}


local UIOptions = {}

local function saveConfig(configName)
	if not configName or configName == "" then
		configName = "default"
	end

	local configData = {
		VoidDistancePercent = o.VoidDistancePercent,
		HeightOffset = o.HeightOffset,
		Mode = o.Mode,
		SpinSpeed = o.SpinSpeed,
		OrbitSpeed = o.OrbitSpeed,
		OrbitRadius = o.OrbitRadius,
		FloatSpeed = o.FloatSpeed,
		FloatIntensity = o.FloatIntensity,
		JitterIntensity = o.JitterIntensity,
		DesyncSpeed = o.DesyncSpeed,
		AAEnabled = o.AAEnabled,
		AAMode = o.AAMode,
		AAPitch = o.AAPitch,
		AASpeed = o.AASpeed,
		JitterRange = o.JitterRange,
		SoundId = o.SoundId,
		HitsoundId = o.HitsoundId,
		OrbitEnabled = o.OrbitEnabled,
		OrbitDistance = o.OrbitDistance,
		OrbitHeightOffset = o.OrbitHeightOffset,
		OrbitUpdateRate = o.OrbitUpdateRate,
		OrbitAroundEnemy = o.OrbitAroundEnemy,
		OrbitAroundRadius = o.OrbitAroundRadius,
		OrbitAroundSpeed = o.OrbitAroundSpeed,
		AlwaysHit = o.AlwaysHit,
		RapidFire = o.RapidFire,
		AutoLoadConfig = o.AutoLoadConfig,
		LastLoadedConfig = configName,
		HitEffectType = o.HitEffectType,
		HitEffectEnabled = o.HitEffectEnabled,
		HitEffectFadeInTime = o.HitEffectFadeInTime,
		HitEffectFadeOutTime = o.HitEffectFadeOutTime,
		HitEffectColor = {o.HitEffectColor.R, o.HitEffectColor.G, o.HitEffectColor.B},
		-- Lighting Settings
		LightingEnabled = o.LightingEnabled,
		Brightness = o.Brightness,
		AmbientColor = {o.AmbientColor.R, o.AmbientColor.G, o.AmbientColor.B},
		OutdoorAmbient = {o.OutdoorAmbient.R, o.OutdoorAmbient.G, o.OutdoorAmbient.B},
		ClockTime = o.ClockTime,
		FogEnd = o.FogEnd,
		FogColor = {o.FogColor.R, o.FogColor.G, o.FogColor.B},
		-- Chams Settings
		ChamsEnabled = o.ChamsEnabled,
		ChamsFillColor = {o.ChamsFillColor.R, o.ChamsFillColor.G, o.ChamsFillColor.B},
		ChamsFillTransparency = o.ChamsFillTransparency,
		ChamsOutlineColor = {o.ChamsOutlineColor.R, o.ChamsOutlineColor.G, o.ChamsOutlineColor.B},
		ChamsOutlineTransparency = o.ChamsOutlineTransparency,
		-- ESP Settings
		ESPEnabled = o.ESPEnabled,
		ESPIgnoreTeammates = o.ESPIgnoreTeammates,
		ESPShowBox = o.ESPShowBox,
		ESPShowName = o.ESPShowName,
		ESPShowDistance = o.ESPShowDistance,
		ESPShowHealthBar = o.ESPShowHealthBar,
		ESPShowSkeleton = o.ESPShowSkeleton,
		ESPShowTracers = o.ESPShowTracers,
		ESPMaxDistance = o.ESPMaxDistance,
		ESPColor = {o.ESPColor.R, o.ESPColor.G, o.ESPColor.B},
		ESPTeamColor = {o.ESPTeamColor.R, o.ESPTeamColor.G, o.ESPTeamColor.B},
		ESPBoxThickness = o.ESPBoxThickness,
		ESPBoxFilled = o.ESPBoxFilled,
		ESPBoxFillTransparency = o.ESPBoxFillTransparency,
		ESPNameColor = {o.ESPNameColor.R, o.ESPNameColor.G, o.ESPNameColor.B},
		ESPNameSize = o.ESPNameSize,
		ESPNameOutline = o.ESPNameOutline,
		ESPDistColor = {o.ESPDistColor.R, o.ESPDistColor.G, o.ESPDistColor.B},
		ESPDistSize = o.ESPDistSize,
		ESPDistOutline = o.ESPDistOutline,
		ESPTracerThickness = o.ESPTracerThickness,
		ESPTracerOrigin = o.ESPTracerOrigin,
		ESPSkeletonThickness = o.ESPSkeletonThickness,
		ESPHealthBarWidth = o.ESPHealthBarWidth,
	}

	local success, err = pcall(function()
		local jsonData = HttpService:JSONEncode(configData)
		writefile(configFolder .. "/" .. configName .. ".json", jsonData)
	end)

	if success then
		a:Notify("Config '" .. configName .. "' saved!", 2)
		o.LastLoadedConfig = configName


	else
		a:Notify("Failed to save config: " .. tostring(err), 3)
	end

	return success
end

local function loadConfig(configName)
	if not configName or configName == "" then
		configName = "default"
	end

	local filePath = configFolder .. "/" .. configName .. ".json"

	if not isfile(filePath) then
		a:Notify("Config '" .. configName .. "' not found!", 2)
		return false
	end

	local success, result = pcall(function()
		local jsonData = readfile(filePath)
		return HttpService:JSONDecode(jsonData)
	end)

	if success and result then
		-- Update settings
		o.VoidDistancePercent = result.VoidDistancePercent or o.VoidDistancePercent
		o.VoidDistance = o.VoidDistancePercent * 500000
		o.HeightOffset = result.HeightOffset or o.HeightOffset
		o.Mode = result.Mode or o.Mode
		o.SpinSpeed = result.SpinSpeed or o.SpinSpeed
		o.OrbitSpeed = result.OrbitSpeed or o.OrbitSpeed
		o.OrbitRadius = result.OrbitRadius or o.OrbitRadius
		o.FloatSpeed = result.FloatSpeed or o.FloatSpeed
		o.FloatIntensity = result.FloatIntensity or o.FloatIntensity
		o.JitterIntensity = result.JitterIntensity or o.JitterIntensity
		o.DesyncSpeed = result.DesyncSpeed or o.DesyncSpeed
		o.AAEnabled = result.AAEnabled or false
		o.AAMode = result.AAMode or o.AAMode
		o.AAPitch = result.AAPitch or o.AAPitch
		o.AASpeed = result.AASpeed or o.AASpeed
		o.JitterRange = result.JitterRange or o.JitterRange
		o.SoundId = result.SoundId or o.SoundId

		o.HitsoundId = result.HitsoundId or o.HitsoundId
		o.OrbitEnabled = result.OrbitEnabled or false
		o.OrbitDistance = result.OrbitDistance or o.OrbitDistance
		o.OrbitHeightOffset = result.OrbitHeightOffset or o.OrbitHeightOffset
		o.OrbitUpdateRate = 0.01
		o.OrbitAroundEnemy = result.OrbitAroundEnemy or false
		o.OrbitAroundRadius = result.OrbitAroundRadius or o.OrbitAroundRadius
		o.OrbitAroundSpeed = result.OrbitAroundSpeed or o.OrbitAroundSpeed
		o.AlwaysHit = result.AlwaysHit or false
		o.RapidFire = result.RapidFire or false
		o.AutoLoadConfig = result.AutoLoadConfig or o.AutoLoadConfig
		o.LastLoadedConfig = configName
		o.HitEffectType = result.HitEffectType or o.HitEffectType
		o.HitEffectEnabled = result.HitEffectEnabled ~= nil and result.HitEffectEnabled or o.HitEffectEnabled
		o.HitEffectFadeInTime = result.HitEffectFadeInTime or o.HitEffectFadeInTime
		o.HitEffectFadeOutTime = result.HitEffectFadeOutTime or o.HitEffectFadeOutTime
		if result.HitEffectColor then
			o.HitEffectColor = Color3.new(result.HitEffectColor[1], result.HitEffectColor[2], result.HitEffectColor[3])
		end
		
		-- Lighting Settings
		o.LightingEnabled = result.LightingEnabled or false
		o.Brightness = result.Brightness or o.Brightness
		if result.AmbientColor then
			o.AmbientColor = Color3.new(result.AmbientColor[1], result.AmbientColor[2], result.AmbientColor[3])
		end
		if result.OutdoorAmbient then
			o.OutdoorAmbient = Color3.new(result.OutdoorAmbient[1], result.OutdoorAmbient[2], result.OutdoorAmbient[3])
		end
		o.ClockTime = result.ClockTime or o.ClockTime
		o.FogEnd = result.FogEnd or o.FogEnd
		if result.FogColor then
			o.FogColor = Color3.new(result.FogColor[1], result.FogColor[2], result.FogColor[3])
		end
		
		-- Chams Settings
		o.ChamsEnabled = result.ChamsEnabled or false
		if result.ChamsFillColor then
			o.ChamsFillColor = Color3.new(result.ChamsFillColor[1], result.ChamsFillColor[2], result.ChamsFillColor[3])
		end
		o.ChamsFillTransparency = result.ChamsFillTransparency or o.ChamsFillTransparency
		if result.ChamsOutlineColor then
			o.ChamsOutlineColor = Color3.new(result.ChamsOutlineColor[1], result.ChamsOutlineColor[2], result.ChamsOutlineColor[3])
		end
		o.ChamsOutlineTransparency = result.ChamsOutlineTransparency or o.ChamsOutlineTransparency

		-- ESP Settings
		o.ESPEnabled = result.ESPEnabled or false
		o.ESPIgnoreTeammates = result.ESPIgnoreTeammates ~= nil and result.ESPIgnoreTeammates or o.ESPIgnoreTeammates
		o.ESPShowBox = result.ESPShowBox ~= nil and result.ESPShowBox or o.ESPShowBox
		o.ESPShowName = result.ESPShowName ~= nil and result.ESPShowName or o.ESPShowName
		o.ESPShowDistance = result.ESPShowDistance ~= nil and result.ESPShowDistance or o.ESPShowDistance
		o.ESPShowHealthBar = result.ESPShowHealthBar ~= nil and result.ESPShowHealthBar or o.ESPShowHealthBar
		o.ESPShowSkeleton = result.ESPShowSkeleton or false
		o.ESPShowTracers = result.ESPShowTracers or false
		o.ESPMaxDistance = result.ESPMaxDistance or o.ESPMaxDistance
		if result.ESPColor then o.ESPColor = Color3.new(result.ESPColor[1], result.ESPColor[2], result.ESPColor[3]) end
		if result.ESPTeamColor then o.ESPTeamColor = Color3.new(result.ESPTeamColor[1], result.ESPTeamColor[2], result.ESPTeamColor[3]) end
		o.ESPBoxThickness = result.ESPBoxThickness or o.ESPBoxThickness
		o.ESPBoxFilled = result.ESPBoxFilled or false
		o.ESPBoxFillTransparency = result.ESPBoxFillTransparency or o.ESPBoxFillTransparency
		if result.ESPNameColor then o.ESPNameColor = Color3.new(result.ESPNameColor[1], result.ESPNameColor[2], result.ESPNameColor[3]) end
		o.ESPNameSize = result.ESPNameSize or o.ESPNameSize
		o.ESPNameOutline = result.ESPNameOutline ~= nil and result.ESPNameOutline or o.ESPNameOutline
		if result.ESPDistColor then o.ESPDistColor = Color3.new(result.ESPDistColor[1], result.ESPDistColor[2], result.ESPDistColor[3]) end
		o.ESPDistSize = result.ESPDistSize or o.ESPDistSize
		o.ESPDistOutline = result.ESPDistOutline ~= nil and result.ESPDistOutline or o.ESPDistOutline
		o.ESPTracerThickness = result.ESPTracerThickness or o.ESPTracerThickness
		o.ESPTracerOrigin = result.ESPTracerOrigin or o.ESPTracerOrigin
		o.ESPSkeletonThickness = result.ESPSkeletonThickness or o.ESPSkeletonThickness
		o.ESPHealthBarWidth = result.ESPHealthBarWidth or o.ESPHealthBarWidth

		-- UPDATE ONLY THE UI ELEMENTS THAT ACTUALLY EXIST!
		if UIOptions.VoidDistSlider then UIOptions.VoidDistSlider:SetValue(o.VoidDistancePercent) end
		if UIOptions.OrbitDistSlider then UIOptions.OrbitDistSlider:SetValue(o.OrbitDistance) end
		if UIOptions.OrbitHeightSlider then UIOptions.OrbitHeightSlider:SetValue(o.OrbitHeightOffset) end
		if UIOptions.OrbitAroundCheckbox then UIOptions.OrbitAroundCheckbox:SetValue(o.OrbitAroundEnemy) end
		if UIOptions.OrbitAroundRadiusSlider then UIOptions.OrbitAroundRadiusSlider:SetValue(o.OrbitAroundRadius) end
		if UIOptions.OrbitAroundSpeedSlider then UIOptions.OrbitAroundSpeedSlider:SetValue(o.OrbitAroundSpeed) end
		if UIOptions.AlwaysHitCheckbox then UIOptions.AlwaysHitCheckbox:SetValue(o.AlwaysHit) end
		if UIOptions.RapidFireCheckbox then UIOptions.RapidFireCheckbox:SetValue(o.RapidFire) end
		if UIOptions.AAEnabledCheckbox then UIOptions.AAEnabledCheckbox:SetValue(o.AAEnabled) end
		if UIOptions.AAModeDropdown then UIOptions.AAModeDropdown:SetValue(o.AAMode) end
		if UIOptions.AAPitchDropdown then UIOptions.AAPitchDropdown:SetValue(o.AAPitch) end
		if UIOptions.JitterRangeSlider then UIOptions.JitterRangeSlider:SetValue(o.JitterRange) end

		if UIOptions.HitsoundDropdown then 
			local hitsoundNames = {
				[719384308] = "Space",
				[140323850218372] = "Pop",
				[18794851884] = "Bonk",
				[83717596220569] = "Skeet",
				[97643101798871] = "Neverlose",
				[70557734865364] = "Slip",
				[5043539486] = "Rust",
			}
			UIOptions.HitsoundDropdown:SetValue(hitsoundNames[o.HitsoundId] or "Space")
		end
		if UIOptions.AutoLoadCheckbox then UIOptions.AutoLoadCheckbox:SetValue(o.AutoLoadConfig) end
		if UIOptions.HitEffectTypeDropdown then UIOptions.HitEffectTypeDropdown:SetValue(o.HitEffectType) end
		if UIOptions.HitEffectEnabledCheckbox then UIOptions.HitEffectEnabledCheckbox:SetValue(o.HitEffectEnabled) end
		if UIOptions.HitEffectFadeInSlider then UIOptions.HitEffectFadeInSlider:SetValue(o.HitEffectFadeInTime) end
		if UIOptions.HitEffectFadeOutSlider then UIOptions.HitEffectFadeOutSlider:SetValue(o.HitEffectFadeOutTime) end
		if a.Options.HitEffectColor then a.Options.HitEffectColor:SetValueRGB(o.HitEffectColor) end
		
		-- Update Lighting UI
		if UIOptions.LightingEnabledCheckbox then UIOptions.LightingEnabledCheckbox:SetValue(o.LightingEnabled) end
		if UIOptions.BrightnessSlider then UIOptions.BrightnessSlider:SetValue(o.Brightness) end
		if a.Options.AmbientColor then a.Options.AmbientColor:SetValueRGB(o.AmbientColor) end
		if a.Options.OutdoorAmbient then a.Options.OutdoorAmbient:SetValueRGB(o.OutdoorAmbient) end
		if UIOptions.ClockTimeSlider then UIOptions.ClockTimeSlider:SetValue(o.ClockTime) end
		if UIOptions.FogEndSlider then UIOptions.FogEndSlider:SetValue(o.FogEnd) end
		if a.Options.FogColor then a.Options.FogColor:SetValueRGB(o.FogColor) end
		
		-- Update Chams UI
		if UIOptions.ChamsEnabledCheckbox then UIOptions.ChamsEnabledCheckbox:SetValue(o.ChamsEnabled) end
		if a.Options.ChamsFillColor then a.Options.ChamsFillColor:SetValueRGB(o.ChamsFillColor) end
		if UIOptions.ChamsFillTransparencySlider then UIOptions.ChamsFillTransparencySlider:SetValue(o.ChamsFillTransparency) end
		if a.Options.ChamsOutlineColor then a.Options.ChamsOutlineColor:SetValueRGB(o.ChamsOutlineColor) end
		if UIOptions.ChamsOutlineTransparencySlider then UIOptions.ChamsOutlineTransparencySlider:SetValue(o.ChamsOutlineTransparency) end

		-- Update ESP UI
		if UIOptions.ESPEnabledCheckbox then UIOptions.ESPEnabledCheckbox:SetValue(o.ESPEnabled) end
		if UIOptions.ESPIgnoreTeammatesCheckbox then UIOptions.ESPIgnoreTeammatesCheckbox:SetValue(o.ESPIgnoreTeammates) end
		if UIOptions.ESPShowBoxCheckbox then UIOptions.ESPShowBoxCheckbox:SetValue(o.ESPShowBox) end
		if UIOptions.ESPShowNameCheckbox then UIOptions.ESPShowNameCheckbox:SetValue(o.ESPShowName) end
		if UIOptions.ESPShowDistanceCheckbox then UIOptions.ESPShowDistanceCheckbox:SetValue(o.ESPShowDistance) end
		if UIOptions.ESPShowHealthBarCheckbox then UIOptions.ESPShowHealthBarCheckbox:SetValue(o.ESPShowHealthBar) end
		if UIOptions.ESPShowSkeletonCheckbox then UIOptions.ESPShowSkeletonCheckbox:SetValue(o.ESPShowSkeleton) end
		if UIOptions.ESPShowTracersCheckbox then UIOptions.ESPShowTracersCheckbox:SetValue(o.ESPShowTracers) end
		if UIOptions.ESPMaxDistanceSlider then UIOptions.ESPMaxDistanceSlider:SetValue(o.ESPMaxDistance) end
		if UIOptions.ESPBoxThicknessSlider then UIOptions.ESPBoxThicknessSlider:SetValue(o.ESPBoxThickness) end
		if UIOptions.ESPBoxFilledCheckbox then UIOptions.ESPBoxFilledCheckbox:SetValue(o.ESPBoxFilled) end
		if UIOptions.ESPBoxFillTransparencySlider then UIOptions.ESPBoxFillTransparencySlider:SetValue(o.ESPBoxFillTransparency) end
		if UIOptions.ESPNameSizeSlider then UIOptions.ESPNameSizeSlider:SetValue(o.ESPNameSize) end
		if UIOptions.ESPNameOutlineCheckbox then UIOptions.ESPNameOutlineCheckbox:SetValue(o.ESPNameOutline) end
		if UIOptions.ESPDistSizeSlider then UIOptions.ESPDistSizeSlider:SetValue(o.ESPDistSize) end
		if UIOptions.ESPDistOutlineCheckbox then UIOptions.ESPDistOutlineCheckbox:SetValue(o.ESPDistOutline) end
		if UIOptions.ESPTracerThicknessSlider then UIOptions.ESPTracerThicknessSlider:SetValue(o.ESPTracerThickness) end
		if UIOptions.ESPTracerOriginDropdown then UIOptions.ESPTracerOriginDropdown:SetValue(o.ESPTracerOrigin) end
		if UIOptions.ESPSkeletonThicknessSlider then UIOptions.ESPSkeletonThicknessSlider:SetValue(o.ESPSkeletonThickness) end
		if UIOptions.ESPHealthBarWidthSlider then UIOptions.ESPHealthBarWidthSlider:SetValue(o.ESPHealthBarWidth) end


		--a:Notify("Config '" .. configName .. "' loaded & UI updated!", 2)
		return true
	else
		a:Notify("Failed to load config: " .. tostring(result), 3)
		return false
	end
end

local function deleteConfig(configName)
	if not configName or configName == "" or configName == "default" then
		a:Notify("Cannot delete default config!", 2)
		return false
	end

	local filePath = configFolder .. "/" .. configName .. ".json"

	if not isfile(filePath) then
		a:Notify("Config '" .. configName .. "' not found!", 2)
		return false
	end

	local success, err = pcall(function()
		delfile(filePath)
	end)

	if success then
		a:Notify("Config '" .. configName .. "' deleted!", 2)
	else
		a:Notify("Failed to delete config: " .. tostring(err), 3)
	end

	return success
end

local function getConfigList()
	if not isfolder(configFolder) then
		return {}
	end

	local configs = {}
	local success, files = pcall(function()
		return listfiles(configFolder)
	end)

	if success and files then
		for _, file in pairs(files) do
			local configName = file:match("([^/\\]+)%.json$")
			if configName then
				table.insert(configs, configName)
			end
		end
	end

	return configs
end

local function initConfigSystem()
	if not isfolder(configFolder) then
		makefolder(configFolder)
	end
	-- Don't auto-load here anymore, we'll do it at the end after UI is created
end

-- Rapid Fire function
local function toggleTableAttribute(attribute, value)
	for _, gcVal in pairs(getgc(true)) do
		if type(gcVal) == "table" and rawget(gcVal, attribute) then
			gcVal[attribute] = value
		end
	end
end

-- Hitsound replacement
local cachedsound = nil
local function replaceSound(obj)
	if cachedsound and obj ~= cachedsound then
		return
	end
	local oldFormatted = "rbxassetid://16537337310"
	if obj.SoundId == oldFormatted or obj.SoundId:find("16537337310") then
		obj.SoundId = "rbxassetid://" .. tostring(o.HitsoundId)
		cachedsound = obj
	end
end
local function updateAllHitsounds()
	for _, obj in ipairs(game:GetDescendants()) do
		if obj:IsA("Sound") then
			replaceSound(obj)
		end
	end
end
updateAllHitsounds()
for _, obj in ipairs(game:GetDescendants()) do
	if obj:IsA("Sound") then
		task.wait()
		replaceSound(obj)
	end
end
game.DescendantAdded:Connect(function(child)
	if child:IsA("Sound") then
		replaceSound(child)
	end
end)

local function p()
	return f and f.Parent and g and g.Parent and h and h.Parent and h.Health > 0
end
local function q()
	if not p() then
		return nil
	end
	return g
end
local function r(s)
	f = s
	g = f:WaitForChild("HumanoidRootPart")
	h = f:WaitForChild("Humanoid")
	i = g.CFrame
end
e.CharacterAdded:Connect(r)
local function isValidTarget(player)
	if player == e then
		return false
	end
	local char = player.Character
	if not char then
		return false
	end
	local humanoid = char:FindFirstChildOfClass("Humanoid")
	local rootPart = char:FindFirstChild("HumanoidRootPart")
	if not humanoid or humanoid.Health <= 0 then
		return false
	end
	if not rootPart then
		return false
	end
	if rootPart:FindFirstChild("TeammateLabel") then
		return false
	end
	local hasForceField = char:FindFirstChildOfClass("ForceField")
	if hasForceField then
		return false
	end
	return true, char, humanoid, rootPart
end
local function findClosestPlayer()
	local weakestPlayer = nil
	local lowestHealth = math.huge
	local closestDistance = math.huge
	local myPos = g.Position

	for _, player in pairs(b:GetPlayers()) do
		local valid, char, humanoid, rootPart = isValidTarget(player)

		if valid and humanoid and rootPart then

			if humanoid.Health <= 0 then
				continue
			end
			if char:FindFirstChildOfClass("ForceField") then
				continue
			end

			if rootPart:FindFirstChild("TeammateLabel") then
				continue
			end

			local health = humanoid.Health
			local distance = (rootPart.Position - myPos).Magnitude
			

			if health < lowestHealth or 
				(health == lowestHealth and distance < closestDistance) then

				lowestHealth = health
				closestDistance = distance
				weakestPlayer = player
			end
		end
	end

	return weakestPlayer
end
local function getPositionBehind(targetChar)
	local targetRoot = targetChar:FindFirstChildOfClass("Part") or targetChar:FindFirstChild("HumanoidRootPart")
	if not targetRoot then
		return nil
	end
	local targetCFrame = targetRoot.CFrame
	local behindOffset = -targetCFrame.LookVector * o.OrbitDistance
	local finalPos = targetCFrame.Position + behindOffset + Vector3.new(0, o.OrbitHeightOffset, 0)
	return CFrame.new(finalPos) * CFrame.Angles(0, targetCFrame:ToEulerAnglesYXZ(), 0)
end
local function getOrbitPosition(targetChar, deltaTime)
	local targetRoot = targetChar:FindFirstChildOfClass("Part") or targetChar:FindFirstChild("HumanoidRootPart")
	if not targetRoot then
		return nil
	end

	-- Update orbit angle
	orbitAngle = orbitAngle + (deltaTime * o.OrbitAroundSpeed)

	-- Calculate orbit position
	local targetPos = targetRoot.Position
	local offsetX = math.cos(orbitAngle) * o.OrbitAroundRadius
	local offsetZ = math.sin(orbitAngle) * o.OrbitAroundRadius
	local finalPos = targetPos + Vector3.new(offsetX, o.OrbitHeightOffset, offsetZ)

	-- Face the target
	local lookAtTarget = CFrame.new(finalPos, targetPos)
	return lookAtTarget
end
local function t(u)
	if not p() then
		return
	end
	o.Enabled = u
	if u then
		i = g.CFrame
		l = false
		a:Notify("Voidhide Enabled.")
	else
		if p() then
			a:Notify("Voidhide Disabled.")
			g.CFrame = i or CFrame.new(0, 10, 0)
			l = true
			m = tick()
			if g:FindFirstChild("AssemblyLinearVelocity") then
				g.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
			end
			if g:FindFirstChild("AssemblyAngularVelocity") then
				g.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
			end
		end
	end
end

initConfigSystem()

local v = a:CreateWindow({
	Title = '<font color="#6366F1">Aby</font><font color="#A5B4FC">rix</font>',
	Center = true,
	AutoShow = true,
	Footer = "Void hide by @e5no",
	Size = UDim2.fromOffset(600, 450),
	ToggleKeybind = Enum.KeyCode.RightShift,
	ShowCustomCursor = false,
})

local rageTab = v:AddTab("Rage", "skull")
local x = rageTab:AddLeftGroupbox("Void Hide")
local y = x:AddCheckbox("EnableVoid", {
	Text = "Enable Void Hide",
	Default = o.Enabled,
	Callback = t

})
y:AddKeyPicker("VoidBind", { 
	Default = "V", 
	SyncToggleState = true,
	Mode = "Toggle",
	Text = "Toggle Void Mode",
})
UIOptions.VoidDistSlider = x:AddSlider("VoidDist", {
	Text = "Void Distance",
	Default = 5, Min = 1, Max = 100, Rounding = 0,
	Suffix = "%",
	Callback = function(z) 
		o.VoidDistancePercent = z
		o.VoidDistance = z * 500000
	end
})
-- Hitsound replacement system
local cachedHitSound = nil
local originalHitSoundId = 16537337310

local function findAndCacheHitSound()
	if cachedHitSound and cachedHitSound.Parent then
		return cachedHitSound
	end

	-- Search for the hit sound
	for _, obj in ipairs(game:GetDescendants()) do
		if obj:IsA("Sound") then
			local soundIdStr = tostring(obj.SoundId)
			if soundIdStr:find(tostring(originalHitSoundId)) then
				cachedHitSound = obj
				return obj
			end
		end
	end
	return nil
end

local function replaceHitSound(sound)
	local soundIdStr = tostring(sound.SoundId)
	if soundIdStr:find(tostring(originalHitSoundId)) then
		sound.SoundId = o.SoundId
		--	sound.Volume = o.SoundVolume
		cachedHitSound = sound
	end
end

-- Replace existing sounds
for _, obj in ipairs(game:GetDescendants()) do
	if obj:IsA("Sound") then
		replaceHitSound(obj)
	end
end

-- Watch for new sounds
game.DescendantAdded:Connect(function(child)
	if child:IsA("Sound") then
		task.wait()
		replaceHitSound(child)
	end
end)

-- Update cached sound when settings change
local function updateCachedSound()
	local sound = findAndCacheHitSound()
	if sound then
		sound.SoundId = o.SoundId
		sound.Volume = o.SoundVolume
	end
end

-- Hitmarker System
local TweenService = game:GetService("TweenService")
local lastHitsoundTime = 0
local enemyHealthTracking = {}

-- Track enemy health
local function initHealthTracking()
	for _, player in pairs(b:GetPlayers()) do
		if player ~= e then
			local char = player.Character
			if char then
				local humanoid = char:FindFirstChild("Humanoid")
				local rootPart = char:FindFirstChild("HumanoidRootPart")
				local head = char:FindFirstChild("Head")
				if humanoid and rootPart and head and not rootPart:FindFirstChild("TeammateLabel") then
					enemyHealthTracking[player.UserId] = {
						health = humanoid.Health,
						headPos = head.Position,
						head = head
					}
				end
			end
		end
	end
end

-- Create visual hitmarker effect
local function createHitmarker(enemyHead, enemyHeadPos)
    if not o.HitEffectEnabled or not f then return end
    
    local myHead = f:FindFirstChild("Head")
    if not myHead then return end
    
    -- Capture positions before enemy might be destroyed
    local myHeadPos = myHead.Position
    local targetPos
    
    -- Use passed position if head is destroyed, otherwise use head's current position
    if enemyHead and enemyHead.Parent then
        targetPos = enemyHead.Position
    elseif enemyHeadPos then
        targetPos = enemyHeadPos
    else
        return -- No valid position
    end
    
    local distance = (myHeadPos - targetPos).Magnitude
    
    -- Create the effect part based on selected type
    local effectPart = nil
    if o.HitEffectType == "Neon" then
        effectPart = Instance.new("Part")
        effectPart.Parent = workspace.CurrentCamera
        effectPart.Size = Vector3.new(0.25, 0.25, distance)
        effectPart.CFrame = CFrame.new(myHeadPos, targetPos) * CFrame.new(0, 0, -distance / 2)
        effectPart.Anchored = true
        effectPart.CanCollide = false
        effectPart.Material = Enum.Material.Neon
        effectPart.Color = o.HitEffectColor
        effectPart.Transparency = 1
    elseif o.HitEffectType == "Glow" then
        effectPart = Instance.new("Part")
        effectPart.Parent = workspace.CurrentCamera
        effectPart.Size = Vector3.new(0.4, 0.4, distance)
        effectPart.CFrame = CFrame.new(myHeadPos, targetPos) * CFrame.new(0, 0, -distance / 2)
        effectPart.Anchored = true
        effectPart.CanCollide = false
        effectPart.Material = Enum.Material.ForceField
        effectPart.Color = o.HitEffectColor
        effectPart.Transparency = 1
    elseif o.HitEffectType == "None" then
        effectPart = Instance.new("Part")
        effectPart.Parent = workspace.CurrentCamera
        effectPart.Size = Vector3.new(0.3, 0.3, distance)
        effectPart.CFrame = CFrame.new(myHeadPos, targetPos) * CFrame.new(0, 0, -distance / 2)
        effectPart.Anchored = true
        effectPart.CanCollide = false
        effectPart.Material = Enum.Material.Glass
        effectPart.Color = o.HitEffectColor
        effectPart.Transparency = 1
    end
    
    if not effectPart then return end
    
    -- Add Highlight instance
    local highlight = Instance.new("Highlight")
    highlight.Parent = effectPart
    highlight.FillColor = o.HitEffectColor
    highlight.OutlineColor = o.HitEffectColor
    highlight.FillTransparency = 0
    highlight.OutlineTransparency = 0
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    
    -- Animate transparency using coroutine instead of tween
    coroutine.wrap(function()
        local fadeInTime = o.HitEffectFadeInTime
        local fadeOutTime = o.HitEffectFadeOutTime
        local fadeInSteps = 20
        local fadeOutSteps = 20
        
        -- Fade in
        for i = 1, fadeInSteps do
            if not effectPart or not effectPart.Parent then break end
            local alpha = i / fadeInSteps
            -- Transparency goes from 1 (invisible) to 0 (visible)
            effectPart.Transparency = 1 - alpha
            if highlight then
                highlight.FillTransparency = 1 - alpha
                highlight.OutlineTransparency = 1 - alpha
            end
            task.wait(fadeInTime / fadeInSteps)
        end
        
        -- Hold briefly
        task.wait(0.05)
        
        -- Fade out
        for i = 1, fadeOutSteps do
            if not effectPart or not effectPart.Parent then break end
            local alpha = i / fadeOutSteps
            -- Transparency goes from 0 (visible) to 1 (invisible)
            effectPart.Transparency = alpha
            if highlight then
                highlight.FillTransparency = alpha
                highlight.OutlineTransparency = alpha
            end
            task.wait(fadeOutTime / fadeOutSteps)
        end
        
        -- Cleanup
        if effectPart then
            effectPart:Destroy()
        end
    end)()
end

-- Monitor hitsound playing
if cachedHitSound then
	cachedHitSound.Played:Connect(function()
		lastHitsoundTime = tick()
	end)
end

-- Monitor when new hitsound is created
game.DescendantAdded:Connect(function(child)
	if child:IsA("Sound") then
		local soundIdStr = tostring(child.SoundId)
		if soundIdStr:find(tostring(originalHitSoundId)) or soundIdStr:find(tostring(o.HitsoundId)) then
			child.Played:Connect(function()
				lastHitsoundTime = tick()
			end)
		end
	end
end)

-- Monitor health changes and trigger hitmarker
coroutine.wrap(function()
    while  task.wait(0.0001) do
		if not o.HitEffectEnabled then return end

		for _, player in pairs(b:GetPlayers()) do
			if player ~= e then
				local char = player.Character
				if char then
					local humanoid = char:FindFirstChild("Humanoid")
					local rootPart = char:FindFirstChild("HumanoidRootPart")
					local head = char:FindFirstChild("Head")

					-- Skip teammates
					if rootPart and rootPart:FindFirstChild("TeammateLabel") then
						continue
					end

					if humanoid and head then -- Check for head existence here to be safe
						local currentHealth = humanoid.Health
						local trackingData = enemyHealthTracking[player.UserId]

						-- Initialize tracking if not exists
						if not trackingData then
							enemyHealthTracking[player.UserId] = {
								health = currentHealth,
								headPos = head.Position,
								head = head
							}
							trackingData = enemyHealthTracking[player.UserId]
						end

						-- CALCULATE DAMAGE DELTA
						-- We check if health dropped, regardless of whether they are dead or alive
						local healthDifference = trackingData.health - currentHealth
					
						if healthDifference > 0 then
							-- Only show hit effect if hitsound played recently (within 0.15 seconds)
							local timeSinceHitsound = tick() - lastHitsoundTime
							if timeSinceHitsound <= 1 then
								coroutine.wrap(function()
									createHitmarker(trackingData.head, trackingData.headPos)
								end)()
							end
						end

				
						trackingData.health = currentHealth
						trackingData.headPos = head.Position
						trackingData.head = head
					end
				end
			end
    end
	end
end)()

-- Initialize tracking
initHealthTracking()

-- Track new players
b.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(char)
		task.wait(1)
		local humanoid = char:FindFirstChild("Humanoid")
		local rootPart = char:FindFirstChild("HumanoidRootPart")
		local head = char:FindFirstChild("Head")
		if humanoid and rootPart and head and not rootPart:FindFirstChild("TeammateLabel") then
			enemyHealthTracking[player.UserId] = {
				health = humanoid.Health,
				headPos = head.Position,
				head = head
			}
		end
	end)
end)

local orbitSettings = rageTab:AddRightGroupbox("Orbit")
orbitSettings:AddCheckbox("EnableOrbit", {
	Text = "Enable Orbit",
	Default = o.OrbitEnabled,
	Callback = function(z) 
		o.OrbitEnabled = z
		if z then
			orbitTarget = findClosestPlayer()
			if orbitTarget then
				a:Notify("Targeting " .. orbitTarget.Name, 2)
			else
				a:Notify("No valid targets found", 2)
			end
		else
			orbitTarget = nil
			a:Notify("Orbit disabled", 1)
		end
	end
}):AddKeyPicker("OrbitBind", { 
	Default = "B", 
	SyncToggleState = true,
	Mode = "Toggle",
	Text = "Toggle Orbit",
})
UIOptions.OrbitDistSlider = orbitSettings:AddSlider("OrbitDist", {
	Text = "Distance Behind",
	Default = 10, Min = 0, Max = 50, Rounding = 1,
	Suffix = " studs",
	Callback = function(z) o.OrbitDistance = z end
})
UIOptions.OrbitHeightSlider = orbitSettings:AddSlider("OrbitHeight", {
	Text = "Height Offset",
	Default = 0, Min = -20, Max = 20, Rounding = 1,
	Suffix = " studs",
	Callback = function(z) o.OrbitHeightOffset = z end
})
o.OrbitUpdateRate = 0.01
UIOptions.OrbitAroundCheckbox = orbitSettings:AddCheckbox("OrbitAround", {
	Text = "Orbit Around Enemy",
	Default = o.OrbitAroundEnemy,
	Callback = function(z) 
		o.OrbitAroundEnemy = z
		if z then
			orbitAngle = 0  -- Reset orbit angle
			a:Notify("Orbit Around Enemy enabled", 2)
		else
			a:Notify("Orbit Around Enemy disabled", 1)
		end
	end
})
UIOptions.OrbitAroundRadiusSlider = orbitSettings:AddSlider("OrbitAroundRadius", {
	Text = "Orbit Radius",
	Default = 10, Min = 5, Max = 50, Rounding = 1,
	Suffix = " studs",
	Callback = function(z) o.OrbitAroundRadius = z end
})
UIOptions.OrbitAroundSpeedSlider = orbitSettings:AddSlider("OrbitAroundSpeed", {
	Text = "Orbit Speed",
	Default = 2, Min = 0.5, Max = 10, Rounding = 1,
	Suffix = " rad/s",
	Callback = function(z) o.OrbitAroundSpeed = z end
})
local exploitsSettings = rageTab:AddLeftGroupbox("Exploits")
UIOptions.AlwaysHitCheckbox = exploitsSettings:AddCheckbox("AlwaysHit", {
	Text = "Always Hit",
	Default = o.AlwaysHit,
	Callback = function(z) 
		o.AlwaysHit = z
		if z then
			a:Notify("Always Hit enabled", 2)
		else
			a:Notify("Always Hit disabled", 1)
		end
	end
})
UIOptions.RapidFireCheckbox = exploitsSettings:AddCheckbox("RapidFire", {
	Text = "Rapid Fire",
	Default = o.RapidFire,
	Callback = function(z) 
		o.RapidFire = z
		if z then
			toggleTableAttribute("ShootCooldown", 0)
			toggleTableAttribute("ShootSpread", 0)
			toggleTableAttribute("ShootRecoil", 0)


		end
	end
})
local ai = rageTab:AddRightGroupbox("Anti Aim")
UIOptions.AAEnabledCheckbox = ai:AddCheckbox("EnableAA", {
	Text = "Enable Anti-Aim",
	Default = o.AAEnabled,
	Callback = function(z) o.AAEnabled = z end
})
UIOptions.AAPitchDropdown = ai:AddDropdown("AAPitch", {
	Values = {"Flip", "Up", "Down", "None"},
	Default = "None",
	Text = "Pitch Angle",
	Callback = function(z) o.AAPitch = z end
})
UIOptions.JitterRangeSlider = ai:AddSlider("JitterRange", {
	Text = "Rotate Amount",
	Default = 45, Min = 0, Max = 360, Rounding = 1,
	Suffix = "%",
	Callback = function(z) o.JitterRange = z end
})
UIOptions.AAModeDropdown = ai:AddDropdown("AAMode", {
	Values = { "Jitter", "Sway", "Inverter", "None"},
	Default = "None",
	Text = "Anti-Aim Type",
	Callback = function(z) o.AAMode = z end
})
-- ====== VISUALS TAB ======
local visualsTab = v:AddTab("Visuals", "eye")

-- Chams Section (left)
local chamsBox = visualsTab:AddLeftGroupbox("Chams")

-- Table to store all active highlights
local activeHighlights = {}

-- Function to create highlight for a character
local function createHighlight(character)
	if not character or not character:FindFirstChild("HumanoidRootPart") then
		return nil
	end
	
	-- Check if already has highlight
	local existingHighlight = character:FindFirstChildOfClass("Highlight")
	if existingHighlight then
		return existingHighlight
	end
	
	-- Create new highlight
	local highlight = Instance.new("Highlight")
	highlight.Name = "ChamsHighlight"
	highlight.FillColor = o.ChamsFillColor
	highlight.FillTransparency = o.ChamsFillTransparency
	highlight.OutlineColor = o.ChamsOutlineColor
	highlight.OutlineTransparency = o.ChamsOutlineTransparency
	highlight.Parent = character
	
	return highlight
end

-- Function to update all highlights
local function updateAllHighlights()
	if not o.ChamsEnabled then
		-- Remove all highlights
		for _, highlight in pairs(activeHighlights) do
			if highlight and highlight.Parent then
				highlight:Destroy()
			end
		end
		activeHighlights = {}
		return
	end
	
	-- Update existing highlights and create new ones
	for _, player in pairs(b:GetPlayers()) do
		if player ~= e then
			local character = player.Character
			if character then
				local rootPart = character:FindFirstChild("HumanoidRootPart")
				
				-- Skip teammates
				if rootPart and rootPart:FindFirstChild("TeammateLabel") then
					-- Remove highlight from teammate if exists
					local highlight = character:FindFirstChildOfClass("Highlight")
					if highlight and highlight.Name == "ChamsHighlight" then
						highlight:Destroy()
					end
				else
					-- Create or update enemy highlight
					local highlight = createHighlight(character)
					if highlight then
						highlight.FillColor = o.ChamsFillColor
						highlight.FillTransparency = o.ChamsFillTransparency
						highlight.OutlineColor = o.ChamsOutlineColor
						highlight.OutlineTransparency = o.ChamsOutlineTransparency
						activeHighlights[player.UserId] = highlight
					end
				end
			end
		end
	end
end

-- Monitor for new players and characters
b.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(character)
		task.wait(0.5)
		if o.ChamsEnabled then
			updateAllHighlights()
		end
	end)
end)

-- Auto-refresh highlights every 2 seconds
coroutine.wrap(function()
	while task.wait(2) do
		if o.ChamsEnabled then
			updateAllHighlights()
		end
	end
end)()

-- Update highlights on heartbeat for real-time changes
c.Heartbeat:Connect(function()
	if o.ChamsEnabled then
		-- Quick check to ensure highlights are still applied
		for userId, highlight in pairs(activeHighlights) do
			if not highlight or not highlight.Parent then
				activeHighlights[userId] = nil
			end
		end
	end
end)

UIOptions.ChamsEnabledCheckbox = chamsBox:AddCheckbox("ChamsEnabled", {
	Text = "Enable Chams",
	Default = o.ChamsEnabled,
	Callback = function(value)
		o.ChamsEnabled = value
		updateAllHighlights()
		if value then
			a:Notify("Chams enabled", 2)
		else
			a:Notify("Chams disabled", 1)
		end
	end
})

chamsBox:AddLabel("Fill Color"):AddColorPicker("ChamsFillColor", {
	Default = o.ChamsFillColor,
	Title = "Fill Color",
	Callback = function(value)
		o.ChamsFillColor = value
		if o.ChamsEnabled then
			for _, highlight in pairs(activeHighlights) do
				if highlight and highlight.Parent then
					highlight.FillColor = value
				end
			end
		end
	end
})

UIOptions.ChamsFillTransparencySlider = chamsBox:AddSlider("ChamsFillTransparency", {
	Text = "Fill Transparency",
	Default = o.ChamsFillTransparency,
	Min = 0,
	Max = 1,
	Rounding = 2,
	Callback = function(value)
		o.ChamsFillTransparency = value
		if o.ChamsEnabled then
			for _, highlight in pairs(activeHighlights) do
				if highlight and highlight.Parent then
					highlight.FillTransparency = value
				end
			end
		end
	end
})

chamsBox:AddLabel("Outline Color"):AddColorPicker("ChamsOutlineColor", {
	Default = o.ChamsOutlineColor,
	Title = "Outline Color",
	Callback = function(value)
		o.ChamsOutlineColor = value
		if o.ChamsEnabled then
			for _, highlight in pairs(activeHighlights) do
				if highlight and highlight.Parent then
					highlight.OutlineColor = value
				end
			end
		end
	end
})

UIOptions.ChamsOutlineTransparencySlider = chamsBox:AddSlider("ChamsOutlineTransparency", {
	Text = "Outline Transparency",
	Default = o.ChamsOutlineTransparency,
	Min = 0,
	Max = 1,
	Rounding = 2,
	Callback = function(value)
		o.ChamsOutlineTransparency = value
		if o.ChamsEnabled then
			for _, highlight in pairs(activeHighlights) do
				if highlight and highlight.Parent then
					highlight.OutlineTransparency = value
				end
			end
		end
	end
})

-- ====== ESP SECTION in Visuals Tab ======
local espLeft  = visualsTab:AddLeftGroupbox("ESP")
local espRight = visualsTab:AddRightGroupbox("ESP Style")

-- Left column: toggles + distance
UIOptions.ESPEnabledCheckbox = espLeft:AddCheckbox("ESPEnabled", {
	Text = "Enable ESP",
	Default = o.ESPEnabled,
	Callback = function(value)
		o.ESPEnabled = value
		if value then a:Notify("ESP enabled", 2) else a:Notify("ESP disabled", 1) end
	end
})

UIOptions.ESPIgnoreTeammatesCheckbox = espLeft:AddCheckbox("ESPIgnoreTeammates", {
	Text = "Ignore Teammates",
	Default = o.ESPIgnoreTeammates,
	Callback = function(value) o.ESPIgnoreTeammates = value end
})

UIOptions.ESPShowBoxCheckbox = espLeft:AddCheckbox("ESPShowBox", {
	Text = "Show Box",
	Default = o.ESPShowBox,
	Callback = function(value) o.ESPShowBox = value end
})

UIOptions.ESPBoxFilledCheckbox = espLeft:AddCheckbox("ESPBoxFilled", {
	Text = "Filled Box",
	Default = o.ESPBoxFilled,
	Callback = function(value) o.ESPBoxFilled = value end
})

UIOptions.ESPShowNameCheckbox = espLeft:AddCheckbox("ESPShowName", {
	Text = "Show Name",
	Default = o.ESPShowName,
	Callback = function(value) o.ESPShowName = value end
})

UIOptions.ESPShowDistanceCheckbox = espLeft:AddCheckbox("ESPShowDistance", {
	Text = "Show Distance",
	Default = o.ESPShowDistance,
	Callback = function(value) o.ESPShowDistance = value end
})

UIOptions.ESPShowHealthBarCheckbox = espLeft:AddCheckbox("ESPShowHealthBar", {
	Text = "Show Health Bar",
	Default = o.ESPShowHealthBar,
	Callback = function(value) o.ESPShowHealthBar = value end
})

UIOptions.ESPShowSkeletonCheckbox = espLeft:AddCheckbox("ESPShowSkeleton", {
	Text = "Show Skeleton",
	Default = o.ESPShowSkeleton,
	Callback = function(value) o.ESPShowSkeleton = value end
})

UIOptions.ESPShowTracersCheckbox = espLeft:AddCheckbox("ESPShowTracers", {
	Text = "Show Tracers",
	Default = o.ESPShowTracers,
	Callback = function(value) o.ESPShowTracers = value end
})

UIOptions.ESPNameOutlineCheckbox = espLeft:AddCheckbox("ESPNameOutline", {
	Text = "Name Outline",
	Default = o.ESPNameOutline,
	Callback = function(value) o.ESPNameOutline = value end
})

UIOptions.ESPDistOutlineCheckbox = espLeft:AddCheckbox("ESPDistOutline", {
	Text = "Distance Outline",
	Default = o.ESPDistOutline,
	Callback = function(value) o.ESPDistOutline = value end
})

UIOptions.ESPMaxDistanceSlider = espLeft:AddSlider("ESPMaxDistance", {
	Text = "Max Distance",
	Default = o.ESPMaxDistance,
	Min = 100, Max = 5000, Rounding = 0, Suffix = " studs",
	Callback = function(value) o.ESPMaxDistance = value end
})

-- Right column: style/thickness/color
UIOptions.ESPBoxThicknessSlider = espRight:AddSlider("ESPBoxThickness", {
	Text = "Box Thickness",
	Default = o.ESPBoxThickness,
	Min = 0.5, Max = 5, Rounding = 1,
	Callback = function(value) o.ESPBoxThickness = value end
})

UIOptions.ESPBoxFillTransparencySlider = espRight:AddSlider("ESPBoxFillTransparency", {
	Text = "Box Fill Opacity",
	Default = o.ESPBoxFillTransparency,
	Min = 0, Max = 1, Rounding = 2,
	Callback = function(value) o.ESPBoxFillTransparency = value end
})

UIOptions.ESPNameSizeSlider = espRight:AddSlider("ESPNameSize", {
	Text = "Name Size",
	Default = o.ESPNameSize,
	Min = 8, Max = 28, Rounding = 0,
	Callback = function(value) o.ESPNameSize = value end
})

UIOptions.ESPDistSizeSlider = espRight:AddSlider("ESPDistSize", {
	Text = "Distance Size",
	Default = o.ESPDistSize,
	Min = 8, Max = 24, Rounding = 0,
	Callback = function(value) o.ESPDistSize = value end
})

UIOptions.ESPTracerThicknessSlider = espRight:AddSlider("ESPTracerThickness", {
	Text = "Tracer Thickness",
	Default = o.ESPTracerThickness,
	Min = 0.5, Max = 5, Rounding = 1,
	Callback = function(value) o.ESPTracerThickness = value end
})

UIOptions.ESPSkeletonThicknessSlider = espRight:AddSlider("ESPSkeletonThickness", {
	Text = "Skeleton Thickness",
	Default = o.ESPSkeletonThickness,
	Min = 0.5, Max = 5, Rounding = 1,
	Callback = function(value) o.ESPSkeletonThickness = value end
})

UIOptions.ESPHealthBarWidthSlider = espRight:AddSlider("ESPHealthBarWidth", {
	Text = "Health Bar Width",
	Default = o.ESPHealthBarWidth,
	Min = 2, Max = 12, Rounding = 0,
	Callback = function(value) o.ESPHealthBarWidth = value end
})

UIOptions.ESPTracerOriginDropdown = espRight:AddDropdown("ESPTracerOrigin", {
	Values = {"Bottom", "Center", "Top"},
	Default = o.ESPTracerOrigin,
	Text = "Tracer Origin",
	Callback = function(value) o.ESPTracerOrigin = value end
})

espRight:AddLabel("Enemy Color"):AddColorPicker("ESPColor", {
	Default = o.ESPColor,
	Title = "Enemy ESP Color",
	Callback = function(value) o.ESPColor = value end
})

espRight:AddLabel("Team Color"):AddColorPicker("ESPTeamColor", {
	Default = o.ESPTeamColor,
	Title = "Team ESP Color",
	Callback = function(value) o.ESPTeamColor = value end
})

espRight:AddLabel("Name Color"):AddColorPicker("ESPNameColor", {
	Default = o.ESPNameColor,
	Title = "Name Text Color",
	Callback = function(value) o.ESPNameColor = value end
})

espRight:AddLabel("Distance Color"):AddColorPicker("ESPDistColor", {
	Default = o.ESPDistColor,
	Title = "Distance Text Color",
	Callback = function(value) o.ESPDistColor = value end
})

-- ====== LIGHTING TAB (moved out of Visuals) ======
local lightingTab = v:AddTab("Lighting", "sun")
local lightingBox = lightingTab:AddLeftGroupbox("Lighting")

-- Store original lighting values
local Lighting = game:GetService("Lighting")
local originalLighting = {
	Brightness    = Lighting.Brightness,
	Ambient       = Lighting.Ambient,
	OutdoorAmbient= Lighting.OutdoorAmbient,
	ClockTime     = Lighting.ClockTime,
	FogEnd        = Lighting.FogEnd,
	FogColor      = Lighting.FogColor
}

local function applyLighting()
	if o.LightingEnabled then
		Lighting.Brightness     = o.Brightness
		Lighting.Ambient        = o.AmbientColor
		Lighting.OutdoorAmbient = o.OutdoorAmbient
		Lighting.ClockTime      = o.ClockTime
		Lighting.FogEnd         = o.FogEnd
		Lighting.FogColor       = o.FogColor
	else
		Lighting.Brightness     = originalLighting.Brightness
		Lighting.Ambient        = originalLighting.Ambient
		Lighting.OutdoorAmbient = originalLighting.OutdoorAmbient
		Lighting.ClockTime      = originalLighting.ClockTime
		Lighting.FogEnd         = originalLighting.FogEnd
		Lighting.FogColor       = originalLighting.FogColor
	end
end

UIOptions.LightingEnabledCheckbox = lightingBox:AddCheckbox("LightingEnabled", {
	Text = "Enable Lighting Changer",
	Default = o.LightingEnabled,
	Callback = function(value)
		o.LightingEnabled = value
		applyLighting()
		if value then a:Notify("Lighting enabled", 2) else a:Notify("Lighting disabled", 1) end
	end
})

UIOptions.BrightnessSlider = lightingBox:AddSlider("Brightness", {
	Text = "Brightness",
	Default = o.Brightness,
	Min = 0, Max = 10, Rounding = 1,
	Callback = function(value)
		o.Brightness = value
		if o.LightingEnabled then Lighting.Brightness = value end
	end
})

lightingBox:AddLabel("Ambient Color"):AddColorPicker("AmbientColor", {
	Default = o.AmbientColor,
	Title = "Ambient Color",
	Callback = function(value)
		o.AmbientColor = value
		if o.LightingEnabled then Lighting.Ambient = value end
	end
})

lightingBox:AddLabel("Outdoor Ambient"):AddColorPicker("OutdoorAmbient", {
	Default = o.OutdoorAmbient,
	Title = "Outdoor Ambient",
	Callback = function(value)
		o.OutdoorAmbient = value
		if o.LightingEnabled then Lighting.OutdoorAmbient = value end
	end
})

UIOptions.ClockTimeSlider = lightingBox:AddSlider("ClockTime", {
	Text = "Time of Day",
	Default = o.ClockTime,
	Min = 0, Max = 24, Rounding = 1, Suffix = " hrs",
	Callback = function(value)
		o.ClockTime = value
		if o.LightingEnabled then Lighting.ClockTime = value end
	end
})

UIOptions.FogEndSlider = lightingBox:AddSlider("FogEnd", {
	Text = "Fog Distance",
	Default = o.FogEnd,
	Min = 1, Max = 5000, Rounding = 0, Suffix = " studs",
	Callback = function(value)
		o.FogEnd = value
		if o.LightingEnabled then Lighting.FogEnd = value end
	end
})

lightingBox:AddLabel("Fog Color"):AddColorPicker("FogColor", {
	Default = o.FogColor,
	Title = "Fog Color",
	Callback = function(value)
		o.FogColor = value
		if o.LightingEnabled then Lighting.FogColor = value end
	end
})

-- ====== MISC TAB ======
local aj = v:AddTab("Misc", "settings")
local ak = aj:AddLeftGroupbox("Settings")
UIOptions.HitsoundDropdown = ak:AddDropdown("SoundSelect", {
	Values = {"Space", "Pop", "Bonk", "Skeet", "Neverlose", "Slip", "Rust"},
	Default = "Space",
	Text = "Hit Sound",
	Callback = function(z)
		local al = {
			["Space"] = "rbxassetid://719384308",
			["Pop"] = "rbxassetid://140323850218372",
			["Bonk"] = "rbxassetid://18794851884",
			["Skeet"] = "rbxassetid://83717596220569",
			["Neverlose"] = "rbxassetid://97643101798871",
			["Slip"] = "rbxassetid://70557734865364",
			["Rust"] = "rbxassetid://5043539486",
		}
		local hitsoundIds = {
			["Space"] = 719384308,
			["Pop"] = 140323850218372,
			["Bonk"] = 18794851884,
			["Skeet"] = 83717596220569,
			["Neverlose"] = 97643101798871,
			["Slip"] = 70557734865364,
			["Rust"] = 5043539486,
		}
		o.SoundId = al[z]
		o.HitsoundId = hitsoundIds[z]
		updateCachedSound()
	end
})

-- Hit Effect Settings
ak:AddLabel("Effect Color"):AddColorPicker("HitEffectColor", {
	Default = o.HitEffectColor,
	Title = "Hit Effect Color",
	Callback = function(z)
		o.HitEffectColor = z
	end
})

UIOptions.HitEffectEnabledCheckbox = ak:AddCheckbox("HitEffectEnabled", {
	Text = "Enable Hit Effect",
	Default = o.HitEffectEnabled,
	Callback = function(z) 
		o.HitEffectEnabled = z
	end
})

UIOptions.HitEffectTypeDropdown = ak:AddDropdown("HitEffectType", {
	Values = {"Neon", "Glow", "None"},
	Default = o.HitEffectType,
	Text = "Effect Type",
	Callback = function(z) 
		o.HitEffectType = z
	end
})

UIOptions.HitEffectFadeInSlider = ak:AddSlider("HitEffectFadeIn", {
	Text = "Fade In Time",
	Default = o.HitEffectFadeInTime,
	Min = 0.05,
	Max = 1,
	Rounding = 2,
	Suffix = "s",
	Callback = function(z) 
		o.HitEffectFadeInTime = z
	end
})

UIOptions.HitEffectFadeOutSlider = ak:AddSlider("HitEffectFadeOut", {
	Text = "Fade Out Time",
	Default = o.HitEffectFadeOutTime,
	Min = 0.1,
	Max = 2,
	Rounding = 2,
	Suffix = "s",
	Callback = function(z) 
		o.HitEffectFadeOutTime = z
	end
})

-- HUD Settings
local hudBox = aj:AddRightGroupbox("HUD")
hudBox:AddCheckbox("ShowActiveHUD", {
	Text = "Show Active HUD",
	Default = true,
	Callback = function(z)
		a:SetHUDVisible(z)
	end
})

-- ====== ESP DRAWING ENGINE ======
local espObjects = {}

local SKELETON_JOINTS = {
	{"Head", "UpperTorso"},
	{"UpperTorso", "LowerTorso"},
	{"UpperTorso", "LeftUpperArm"},
	{"LeftUpperArm", "LeftLowerArm"},
	{"LeftLowerArm", "LeftHand"},
	{"UpperTorso", "RightUpperArm"},
	{"RightUpperArm", "RightLowerArm"},
	{"RightLowerArm", "RightHand"},
	{"LowerTorso", "LeftUpperLeg"},
	{"LeftUpperLeg", "LeftLowerLeg"},
	{"LeftLowerLeg", "LeftFoot"},
	{"LowerTorso", "RightUpperLeg"},
	{"RightUpperLeg", "RightLowerLeg"},
	{"RightLowerLeg", "RightFoot"},
}

local function newDrawing(shape, props)
	local d = Drawing.new(shape)
	for k, vv in pairs(props) do d[k] = vv end
	return d
end

local function getOrCreateESP(player)
	if espObjects[player.Name] then return espObjects[player.Name] end
	local col = Color3.fromRGB(255, 0, 0)
	local obj = {
		Box         = newDrawing("Square", {Visible=false, Color=col, Thickness=1.5, Transparency=1, Filled=false}),
		BoxFill     = newDrawing("Square", {Visible=false, Color=col, Thickness=0,   Transparency=0.85, Filled=true}),
		NameTag     = newDrawing("Text",   {Visible=false, Color=Color3.new(1,1,1), Size=14, Center=true, Outline=true, OutlineColor=Color3.new(0,0,0)}),
		DistTag     = newDrawing("Text",   {Visible=false, Color=Color3.new(1,1,1), Size=12, Center=true, Outline=true, OutlineColor=Color3.new(0,0,0)}),
		HPBarBG     = newDrawing("Square", {Visible=false, Color=Color3.new(0,0,0), Thickness=0, Transparency=1, Filled=true}),
		HPBar       = newDrawing("Square", {Visible=false, Color=Color3.fromRGB(0,255,0), Thickness=0, Transparency=1, Filled=true}),
		Tracer      = newDrawing("Line",   {Visible=false, Color=col, Thickness=1, Transparency=1}),
		SkeletonLines = {},
	}
	for i = 1, #SKELETON_JOINTS do
		obj.SkeletonLines[i] = newDrawing("Line", {Visible=false, Color=col, Thickness=1, Transparency=1})
	end
	espObjects[player.Name] = obj
	return obj
end

local function hideESP(obj)
	obj.Box.Visible     = false
	obj.BoxFill.Visible = false
	obj.NameTag.Visible = false
	obj.DistTag.Visible = false
	obj.HPBarBG.Visible = false
	obj.HPBar.Visible   = false
	obj.Tracer.Visible  = false
	for _, line in pairs(obj.SkeletonLines) do line.Visible = false end
end

local function removeESP(playerName)
	local obj = espObjects[playerName]
	if not obj then return end
	obj.Box:Remove(); obj.BoxFill:Remove(); obj.NameTag:Remove(); obj.DistTag:Remove()
	obj.HPBarBG:Remove(); obj.HPBar:Remove(); obj.Tracer:Remove()
	for _, line in pairs(obj.SkeletonLines) do line:Remove() end
	espObjects[playerName] = nil
end

b.PlayerRemoving:Connect(function(player)
	removeESP(player.Name)
end)

c.RenderStepped:Connect(function()
	if not o.ESPEnabled then
		for _, obj in pairs(espObjects) do hideESP(obj) end
		return
	end

	local myPos = g and g.Position
	if not myPos then return end
	local cam = workspace.CurrentCamera
	local vp  = cam.ViewportSize

	-- Tracer origin point
	local tracerOriginY
	if o.ESPTracerOrigin == "Top" then
		tracerOriginY = 0
	elseif o.ESPTracerOrigin == "Center" then
		tracerOriginY = vp.Y * 0.5
	else -- Bottom
		tracerOriginY = vp.Y
	end
	local tracerOrigin = Vector2.new(vp.X * 0.5, tracerOriginY)

	for _, player in pairs(b:GetPlayers()) do
		if player == e then continue end

		local char     = player.Character
		local obj      = getOrCreateESP(player)
		local rootPart2 = char and char:FindFirstChild("HumanoidRootPart")
		local isTeammate = rootPart2 and rootPart2:FindFirstChild("TeammateLabel") ~= nil

		-- Skip teammates if option is on
		if isTeammate and o.ESPIgnoreTeammates then
			hideESP(obj)
			continue
		end

		local color = isTeammate and o.ESPTeamColor or o.ESPColor

		if not char or not rootPart2 then hideESP(obj) continue end

		local humanoid2 = char:FindFirstChildOfClass("Humanoid")
		local head2     = char:FindFirstChild("Head")
		if not humanoid2 or not head2 then hideESP(obj) continue end

		-- Distance check
		local dist = (rootPart2.Position - myPos).Magnitude
		if dist > o.ESPMaxDistance then hideESP(obj) continue end

		--  ACCURATE BOX BOUNDS 
		-- Use actual head top and lowest available foot for tight fit
		local headSize   = head2.Size.Y * 0.5
		local topWorld   = head2.Position + Vector3.new(0, headSize + 0.05, 0)

		local leftFoot   = char:FindFirstChild("LeftFoot")  or char:FindFirstChild("Left Leg")
		local rightFoot  = char:FindFirstChild("RightFoot") or char:FindFirstChild("Right Leg")
		local footY      = rootPart2.Position.Y - 3.0
		if leftFoot  then footY = math.min(footY, leftFoot.Position.Y  - leftFoot.Size.Y  * 0.5) end
		if rightFoot then footY = math.min(footY, rightFoot.Position.Y - rightFoot.Size.Y * 0.5) end
		local botWorld   = Vector3.new(rootPart2.Position.X, footY, rootPart2.Position.Z)

		local screenTop,  visTop  = cam:WorldToViewportPoint(topWorld)
		local screenBot,  visBot  = cam:WorldToViewportPoint(botWorld)
		local screenRoot, visRoot = cam:WorldToViewportPoint(rootPart2.Position)

		if not visRoot then hideESP(obj) continue end

		local sx    = screenTop.X
		local syTop = screenTop.Y
		local syBot = screenBot.Y

		-- Ensure top is actually above bottom on screen
		if syTop > syBot then syTop, syBot = syBot, syTop end

		local boxH = syBot - syTop
		local boxW = boxH * 0.55
		local boxX = sx - boxW * 0.5
		local boxY = syTop

		--  BOX 
		if o.ESPShowBox then
			obj.Box.Visible   = true
			obj.Box.Color     = color
			obj.Box.Thickness = o.ESPBoxThickness
			obj.Box.Position  = Vector2.new(boxX, boxY)
			obj.Box.Size      = Vector2.new(boxW, boxH)

			if o.ESPBoxFilled then
				obj.BoxFill.Visible      = true
				obj.BoxFill.Color        = color
				obj.BoxFill.Transparency = o.ESPBoxFillTransparency
				obj.BoxFill.Position     = Vector2.new(boxX, boxY)
				obj.BoxFill.Size         = Vector2.new(boxW, boxH)
			else
				obj.BoxFill.Visible = false
			end
		else
			obj.Box.Visible     = false
			obj.BoxFill.Visible = false
		end

		--  NAME TAG 
		if o.ESPShowName then
			obj.NameTag.Visible      = true
			obj.NameTag.Text         = player.Name
			obj.NameTag.Color        = o.ESPNameColor
			obj.NameTag.Size         = o.ESPNameSize
			obj.NameTag.Outline      = o.ESPNameOutline
			obj.NameTag.OutlineColor = Color3.new(0, 0, 0)
			obj.NameTag.Position     = Vector2.new(sx, boxY - o.ESPNameSize - 2)
		else
			obj.NameTag.Visible = false
		end

		--  DISTANCE TAG 
		if o.ESPShowDistance then
			obj.DistTag.Visible      = true
			obj.DistTag.Text         = string.format("[%d studs]", math.floor(dist))
			obj.DistTag.Color        = o.ESPDistColor
			obj.DistTag.Size         = o.ESPDistSize
			obj.DistTag.Outline      = o.ESPDistOutline
			obj.DistTag.OutlineColor = Color3.new(0, 0, 0)
			obj.DistTag.Position     = Vector2.new(sx, syBot + 3)
		else
			obj.DistTag.Visible = false
		end

		--  HEALTH BAR (left side) 
		if o.ESPShowHealthBar then
			local hp      = humanoid2.Health
			local maxHp   = math.max(humanoid2.MaxHealth, 1)
			local ratio   = math.clamp(hp / maxHp, 0, 1)
			local barW    = o.ESPHealthBarWidth
			local barX    = boxX - barW - 2
			local filledH = boxH * ratio

			obj.HPBarBG.Visible  = true
			obj.HPBarBG.Position = Vector2.new(barX, boxY)
			obj.HPBarBG.Size     = Vector2.new(barW, boxH)

			obj.HPBar.Visible  = true
			obj.HPBar.Color    = Color3.fromRGB(
				math.floor(255 * (1 - ratio)),
				math.floor(255 * ratio),
				0
			)
			obj.HPBar.Position = Vector2.new(barX, boxY + (boxH - filledH))
			obj.HPBar.Size     = Vector2.new(barW, filledH)
		else
			obj.HPBarBG.Visible = false
			obj.HPBar.Visible   = false
		end

		--  TRACER 
		if o.ESPShowTracers then
			obj.Tracer.Visible   = true
			obj.Tracer.Color     = color
			obj.Tracer.Thickness = o.ESPTracerThickness
			obj.Tracer.From      = tracerOrigin
			obj.Tracer.To        = Vector2.new(screenRoot.X, screenRoot.Y)
		else
			obj.Tracer.Visible = false
		end

		--  SKELETON 
		if o.ESPShowSkeleton then
			for i, joint in ipairs(SKELETON_JOINTS) do
				local p1   = char:FindFirstChild(joint[1])
				local p2   = char:FindFirstChild(joint[2])
				local line = obj.SkeletonLines[i]
				if p1 and p2 then
					local s1 = cam:WorldToViewportPoint(p1.Position)
					local s2 = cam:WorldToViewportPoint(p2.Position)
					line.Visible   = true
					line.Color     = color
					line.Thickness = o.ESPSkeletonThickness
					line.From      = Vector2.new(s1.X, s1.Y)
					line.To        = Vector2.new(s2.X, s2.Y)
				else
					line.Visible = false
				end
			end
		else
			for _, line in pairs(obj.SkeletonLines) do line.Visible = false end
		end
	end

	-- Cleanup stale ESP entries
	for name in pairs(espObjects) do
		if not b:FindFirstChild(name) then
			removeESP(name)
		end
	end
end)


local configTab = v:AddTab("Config", "folder")
local configLeft = configTab:AddLeftGroupbox("Settings")
local configRight = configTab:AddRightGroupbox("Options")

local currentConfigName = "default"

-- Function to refresh dropdown values
local function refreshConfigDropdown()
	local configs = getConfigList()
	if #configs == 0 then
		configs = {"default"}
	end

	if UIOptions.ConfigDropdown then
		UIOptions.ConfigDropdown:SetValues(configs)
		-- If current config isn't in list, reset to default
		local found = false
		for _, cfg in pairs(configs) do
			if cfg == currentConfigName then
				found = true
				break
			end
		end
		if not found then
			currentConfigName = "default"
			UIOptions.ConfigDropdown:SetValue("default")
		end
	end
	return configs
end

-- Config Dropdown
UIOptions.ConfigDropdown = configLeft:AddDropdown("ConfigSelect", {
	Values = refreshConfigDropdown(),
	Default = "default",
	Text = "Select Config",
	Callback = function(value)
		currentConfigName = value
		if UIOptions.ConfigNameInput then
			UIOptions.ConfigNameInput:SetValue(value)
		end
	end
})

-- Config Name Input (for creating new configs)
UIOptions.ConfigNameInput = configLeft:AddInput("ConfigName", {
	Default = "default",
	Numeric = false,
	Finished = false,
	Text = "New Config Name",
	Placeholder = "Enter config name...",
	Callback = function(value)
		if value and value ~= "" then
			currentConfigName = value
		end
	end
})

configLeft:AddButton({
	Text = "Save Config",
	Func = function()
		if saveConfig(currentConfigName) then
			refreshConfigDropdown()
			if UIOptions.ConfigDropdown then
				UIOptions.ConfigDropdown:SetValue(currentConfigName)
			end
		end
	end,
	DoubleClick = false,
})

configLeft:AddButton({
	Text = "Load Config",
	Func = function()
		if loadConfig(currentConfigName) then
			if UIOptions.ConfigDropdown then
				UIOptions.ConfigDropdown:SetValue(currentConfigName)
			end
		end
	end,
	DoubleClick = false,
})

configLeft:AddButton({
	Text = "Delete Config",
	Func = function()
		if deleteConfig(currentConfigName) then
			refreshConfigDropdown()
			currentConfigName = "default"
			if UIOptions.ConfigDropdown then
				UIOptions.ConfigDropdown:SetValue("default")
			end
			if UIOptions.ConfigNameInput then
				UIOptions.ConfigNameInput:SetValue("default")
			end
		end
	end,
	DoubleClick = true,
	Tooltip = "Double-click to delete"
})

configLeft:AddButton({
	Text = "Refresh Config List",
	Func = function()
		local configs = refreshConfigDropdown()
		if #configs > 0 then
			a:Notify("Found " .. #configs .. " config(s)", 2)
		else
			a:Notify("No configs found", 2)
		end
	end,
	DoubleClick = false,
})

UIOptions.AutoLoadCheckbox = configRight:AddCheckbox("AutoLoad", {
	Text = "AutoLoad",
	Default = o.AutoLoadConfig,
	Callback = function(value)
		o.AutoLoadConfig = value
	end
})



-- Auto-load config after UI is fully set up
if o.AutoLoadConfig then
	local lastConfig = o.LastLoadedConfig or "default"
	if isfile(configFolder .. "/" .. lastConfig .. ".json") then
		loadConfig(lastConfig)
	end
end





c.Heartbeat:Connect(function(am)
	if not p() then
		return
	end
	if not (o.Enabled or o.AAEnabled) then return end
	if not o.Enabled then return end
	local an = g.CFrame
	k += am
	j = (j + am * (o.AASpeed * 10)) % 360
	if o.AAEnabled then
		local ao = 0
		local ap = 0
		local aq = 0
		if o.AAPitch == "Down" then
			ap = math.rad(-90)
		elseif o.AAPitch == "Flip" then
			ap = math.rad(-180)
		elseif o.AAPitch == "Up" then
			ap = math.rad(90)
		end
		if o.AAMode == "Jitter" then
			ao = math.rad(math.random(-o.JitterRange, o.JitterRange))
		elseif o.AAMode == "Sway" then
			ao = math.sin(k * (o.AASpeed / 5)) * math.rad(o.JitterRange)
		elseif o.AAMode == "Inverter" then
			ao = (math.floor(k * 2) % 2 == 0) and 0 or math.rad(180)
		end
		an = an * CFrame.Angles(ap, ao, 0)
		if o.AAMode == "Flip" then
			an = an * CFrame.Angles(0, 0, math.rad(180))
		end
		g.CFrame = an
	end
end)
c.Heartbeat:Connect(function(am)
	if not p() then
		return
	end
	if not o.OrbitEnabled then
		return
	end
	lastOrbitUpdate += am
	if lastOrbitUpdate >= o.OrbitUpdateRate then
		lastOrbitUpdate = 0
		if orbitTarget then
			local valid = isValidTarget(orbitTarget)
			if not valid then
				orbitTarget = findClosestPlayer()
			end
		else
			orbitTarget = findClosestPlayer()
		end
	end
	if orbitTarget then
		local valid, char = isValidTarget(orbitTarget)
		if valid and char then
			local targetCFrame
			if o.OrbitAroundEnemy then
				-- Orbit around the enemy in a circle
				targetCFrame = getOrbitPosition(char, am)
			else
				-- Stay behind the enemy
				targetCFrame = getPositionBehind(char)
			end
			if targetCFrame then
				g.CFrame = targetCFrame
			end
		end
	end
end)
c.Heartbeat:Connect(function(am)
	if not p() then
		return
	end
	if l then
		local ar = tick() - m
		if ar < n then
			g.CFrame = i or CFrame.new(0, 10, 0)
			g.Velocity = Vector3.new(0, 0, 0)
			if g:FindFirstChild("AssemblyLinearVelocity") then
				g.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
			end
			if g:FindFirstChild("AssemblyAngularVelocity") then
				g.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
			end
		else
			l = false
		end
		return
	end
	if not o.Enabled then return end
	k += am
	j += am * o.SpinSpeed
	local as = Vector3.new(0, o.VoidDistance + o.HeightOffset, 0)
	local an = CFrame.new(as)
	if o.Mode == "Spin" then
		an = CFrame.new(as) * CFrame.Angles(0, j, 0)
	elseif o.Mode == "Orbit" then
		local at = math.cos(k * o.SpinSpeed) * o.OrbitRadius 
		local au = math.sin(k * o.SpinSpeed) * o.OrbitRadius 
		an = CFrame.new(Vector3.new(at, o.VoidDistance + o.HeightOffset, au))
	elseif o.Mode == "Random" then
		local av = math.random(-o.OrbitRadius, o.OrbitRadius)
		local aw = math.random(-o.OrbitRadius, o.OrbitRadius)
		an = CFrame.new(Vector3.new(av, o.VoidDistance + o.HeightOffset, aw))
	elseif o.Mode == "Desync" then
		local ax = o.DesyncSpeed
		an = CFrame.new(as) * CFrame.new(math.sin(k * ax) * 10, 0, math.cos(k * ax) * 10)
		an *= CFrame.Angles(math.random(), math.random(), math.random())
	end
	g.CFrame = an
end)
local Players = game:FindFirstChildOfClass("Players") 
local RunService = game:GetService("RunService") 
local Workspace = game:GetService("Workspace") 
local LocalPlayer = Players.LocalPlayer 

RunService.RenderStepped:Connect(function() 
	if not o.AlwaysHit then
			return 
	end
    local localChar = LocalPlayer.Character 
    if not localChar then return end 
     
    local localHead = localChar:FindFirstChild("Head") 
    if not localHead then return end 
    
    -- Find the Bow part in the character
    local bow = nil
    
    for _, child in pairs(Workspace:GetChildren()) do 
		if child:IsA("BasePart") or child:IsA("MeshPart") or child:IsA("Part") then 
			if child.Name == "Bow" or child.Name == "Daggers" or child.Name == "Slingshot" then 
				bow = child 
			end 
		end 
	end
	if not bow then
		return 
	end
	local bowwow = nil
	for _, child in pairs(bow:GetChildren()) do 
		if child:IsA("BasePart") or child:IsA("MeshPart") or child:IsA("Part") then 
			if child.Name == "Bow" or child.Name == "Daggers" or child.Name == "Slingshot" then 
				bowwow = child 
			end 
		end 
	end
    

  
     
    for _, player in ipairs(Players:GetPlayers()) do 
        if player == LocalPlayer then continue end 
         
        local char = player.Character 
        if not char then continue end 
         
        local rootPart = char:FindFirstChild("HumanoidRootPart") 
        if rootPart and rootPart:FindFirstChild("TeammateLabel") then 
            continue 
        end 
         
      
		for _, child in pairs(char:GetChildren()) do 
		   if child.Name == "HitboxHead" or child.Name == "HitboxHeadSmall" then
			  
					-- Set Bow position to enemy's head
				--  bow.Position = hitbox.Position
				    child.Position = localHead.Position
				    local hitbox = child
					firetouchinterest(hitbox, bow, 0)
					firetouchinterest(hitbox, bowwow, 0)
					
				--  hitbox.Transparency = 0 
				
					if hitbox.Size ~= Vector3.new(1000,1000,1000) then 
						hitbox.Size = Vector3.new(1000,1000,1000) 
					end 
				
		   end
		end
         
    
         
      
    end 
end)


-- Function to apply lighting settings
local function applyLightingSettings()
	if not o.LightingEnabled then return end
	
	local Lighting = game:GetService("Lighting")
	Lighting.Brightness = o.Brightness
	Lighting.Ambient = o.AmbientColor
	Lighting.OutdoorAmbient = o.OutdoorAmbient
	Lighting.ClockTime = o.ClockTime
	Lighting.FogEnd = o.FogEnd
	Lighting.FogColor = o.FogColor
end

-- Coroutine to apply lighting every 2 seconds
coroutine.wrap(function()
	while task.wait(2) do
		applyLightingSettings()
	end
end)()

a:Notify("Press RightShift to toggle UI.")
